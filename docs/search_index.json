[
["index.html", "HTTP mocking and testing in R Chapter 1 Preamble", " HTTP mocking and testing in R built w/ vcr v0.2.6.9100 / webmockr v0.3.4.9100 / crul v0.7.4.9310 / curl v3.3 built on 2019-06-13 Chapter 1 Preamble This book is intended as a detailed guide to using a particular suite of packages for HTTP mocking and testing in R code and/or packages. Info Source: https://github.com/ropensci/http-testing-book/ Issues/Bug reports: https://github.com/ropensci/http-testing-book/issues Packages crul: https://cran.rstudio.com/web/packages/crul/ webmockr: https://cran.rstudio.com/web/packages/webmockr/ vcr: https://github.com/ropensci/vcr/ curl: https://github.com/jeroen/curl/ Installation Stable version from CRAN install.packages(c(&quot;crul&quot;, &quot;webmockr&quot;, &quot;vcr&quot;)) none of crul, webmockr or vcr have compiled code, but an underlying dependency of all of them, curl does. See curl’s README for installation instructions in case you run into curl related problems. "],
["intro.html", "Chapter 2 Introduction 2.1 What is webmockr? 2.2 What is vcr? 2.3 Why crul? 2.4 Use cases", " Chapter 2 Introduction 2.1 What is webmockr? webmockr is an R package to help you “mock” HTTP requests. What does mock mean? Mock refers to the fact that we’re faking the response. Here is how it works: You “stub” a request. That is, you set rules for what HTTP request you’d like to match on You also can set rules for what you’d like to respond with, if anything (if nothing, then we give you NULL) Then you make HTTP requests, and those that match your stub will return what you requested be returned While webmockr is in use, real HTTP interactions are not allowed There is no recording interactions to disk at all, just mocked responses given as the user specifies in the R session webmockr works with both the crul package and the httr package. Read more about webmockr in Section 2. 2.2 What is vcr? The short version is: vcr helps you stub HTTP requests so you don’t have to repeat HTTP requests. The main use case is for unit tests for R packages. vcr works with both the crul package and the httr package. vcr works by hooking into webmockr. However, when webmockr finds a match, we then look for a recorded interaction on disk. If one is not found, we record the request and response. If one is found, we use that recorded interaction to construct a real response as the R client expects. Read more about webmockr in Section 3. 2.3 Why crul? crul is just one of the HTTP clients in R. It’s the one that I maintain though, so was easiest to get started with adding mocking integration. There is now integration with httr for both webmockr and vcr. The major feature that httr has that crul does not have is OAuth support, but that’s not an important use case for me so is not a high priority for crul. A major reason to use crul over httr is that it uses more of an object oriented interface. That is, you create objects that you can call methods on and retrieve variables/results from calls/etc. It’s a different approach than httr which focuses on passing things to functions. 2.4 Use cases 2.4.1 mocking use cases one two three 2.4.2 caching use cases one two three "],
["mocking.html", "Chapter 3 Mocking HTTP Requests 3.1 Features 3.2 How webmockr works in detail 3.3 Basic usage", " Chapter 3 Mocking HTTP Requests The very very short version is: webmockr helps you stub HTTP requests so you don’t have to repeat yourself. 3.1 Features Stubbing HTTP requests at low http client lib level Setting and verifying expectations on HTTP requests Matching requests based on method, URI, headers and body Support for testthat via vcr Can be used for testing or outside of a testing context 3.2 How webmockr works in detail You tell webmockr what HTTP request you want to match against and if it sees a request matching your criteria it doesn’t actually do the HTTP request. Instead, it gives back the same object you would have gotten back with a real request, but only with the bits it knows about. For example, we can’t give back the actual data you’d get from a real HTTP request as the request wasn’t performed. In addition, if you set an expectation of what webmockr should return, we return that. For example, if you expect a request to return a 418 error (I’m a Teapot), then that’s what you’ll get. What you can match against HTTP method (required) Plus any single or combination of the following: URI Right now, we can match directly against URI’s, and with regex URI patterns. Eventually, we will support RFC 6570 URI templates. We normalize URI paths so that URL encoded things match URL un-encoded things (e.g. hello world to hello%20world) Query parameters We normalize query parameter values so that URL encoded things match URL un-encoded things (e.g. message = hello world to message = hello%20world) Request headers We normalize headers and treat all forms of same headers as equal. For example, the following two sets of headers are equal: list(H1 = &quot;value1&quot;, content_length = 123, X_CuStOm_hEAder = &quot;foo&quot;) list(h1 = &quot;value1&quot;, &quot;Content-Length&quot; = 123, &quot;x-cuSTOM-HeAder&quot; = &quot;foo&quot;) Request body Real HTTP requests There’s a few scenarios to think about when using webmockr: After doing library(webmockr) webmockr is loaded but not turned on. At this point webmockr doesn’t change anythning. Once you turn on webmockr like webmockr::enable() webmockr will now by default not allow real HTTP requests from the http libraries that adapters are loaded for (right now only crul). You can optionally allow real requests via webmockr_allow_net_connect(), and disallow real requests via webmockr_disable_net_connect(). You can check whether you are allowing real requests with webmockr_net_connect_allowed(). Certain kinds of real HTTP requests allowed: We don’t suppoprt this yet, but you can allow localhost HTTP requests with the allow_localhost parameter in the webmockr_configure() function. Storing actual HTTP responses webmockr doesn’t do that. Check out vcr 3.3 Basic usage library(&quot;webmockr&quot;) # enable webmockr webmockr::enable() Stubbed request based on uri only and with the default response stub_request(&quot;get&quot;, &quot;https://httpbin.org/get&quot;) #&gt; &lt;webmockr stub&gt; #&gt; method: get #&gt; uri: https://httpbin.org/get #&gt; with: #&gt; query: #&gt; body: #&gt; request_headers: #&gt; to_return: #&gt; status: #&gt; body: #&gt; response_headers: #&gt; should_timeout: FALSE #&gt; should_raise: FALSE library(&quot;crul&quot;) x &lt;- HttpClient$new(url = &quot;https://httpbin.org&quot;) x$get(&#39;get&#39;) #&gt; &lt;crul response&gt; #&gt; url: https://httpbin.org/get #&gt; request_headers: #&gt; User-Agent: libcurl/7.54.0 r-curl/3.3 crul/0.7.4.9310 #&gt; Accept-Encoding: gzip, deflate #&gt; Accept: application/json, text/xml, application/xml, */* #&gt; response_headers: #&gt; status: 200 "],
["webmockr-stubs.html", "Chapter 4 stubs", " Chapter 4 stubs library(&quot;webmockr&quot;) set return objects stub_request(&quot;get&quot;, &quot;https://httpbin.org/get&quot;) %&gt;% wi_th( query = list(hello = &quot;world&quot;)) %&gt;% to_return(status = 418) #&gt; &lt;webmockr stub&gt; #&gt; method: get #&gt; uri: https://httpbin.org/get #&gt; with: #&gt; query: hello=world #&gt; body: #&gt; request_headers: #&gt; to_return: #&gt; status: 418 #&gt; body: #&gt; response_headers: #&gt; should_timeout: FALSE #&gt; should_raise: FALSE x$get(&#39;get&#39;, query = list(hello = &quot;world&quot;)) #&gt; &lt;crul response&gt; #&gt; url: https://httpbin.org/get?hello=world #&gt; request_headers: #&gt; User-Agent: libcurl/7.54.0 r-curl/3.3 crul/0.7.4.9310 #&gt; Accept-Encoding: gzip, deflate #&gt; Accept: application/json, text/xml, application/xml, */* #&gt; response_headers: #&gt; params: #&gt; hello: world #&gt; status: 418 Stubbing requests based on method, uri and query params stub_request(&quot;get&quot;, &quot;https://httpbin.org/get&quot;) %&gt;% wi_th(query = list(hello = &quot;world&quot;), headers = list(&#39;User-Agent&#39; = &#39;libcurl/7.51.0 r-curl/2.6 crul/0.3.6&#39;, &#39;Accept-Encoding&#39; = &quot;gzip, deflate&quot;)) #&gt; &lt;webmockr stub&gt; #&gt; method: get #&gt; uri: https://httpbin.org/get #&gt; with: #&gt; query: hello=world #&gt; body: #&gt; request_headers: User-Agent=libcurl/7.51.0 r-cur..., Accept-Encoding=gzip, deflate #&gt; to_return: #&gt; status: #&gt; body: #&gt; response_headers: #&gt; should_timeout: FALSE #&gt; should_raise: FALSE stub_registry() #&gt; &lt;webmockr stub registry&gt; #&gt; Registered Stubs #&gt; GET: https://httpbin.org/get #&gt; GET: https://httpbin.org/get?hello=world | to_return: with status 418 #&gt; GET: https://httpbin.org/get?hello=world with headers {&quot;User-Agent&quot;:&quot;libcurl/7.51.0 r-curl/2.6 crul/0.3.6&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;} x &lt;- HttpClient$new(url = &quot;https://httpbin.org&quot;) x$get(&#39;get&#39;, query = list(hello = &quot;world&quot;)) #&gt; &lt;crul response&gt; #&gt; url: https://httpbin.org/get?hello=world #&gt; request_headers: #&gt; User-Agent: libcurl/7.54.0 r-curl/3.3 crul/0.7.4.9310 #&gt; Accept-Encoding: gzip, deflate #&gt; Accept: application/json, text/xml, application/xml, */* #&gt; response_headers: #&gt; params: #&gt; hello: world #&gt; status: 418 Stubbing requests and set expectation of a timeout stub_request(&quot;post&quot;, &quot;https://httpbin.org/post&quot;) %&gt;% to_timeout() x &lt;- HttpClient$new(url = &quot;https://httpbin.org&quot;) x$post(&#39;post&#39;) #&gt; Error: Request Timeout (HTTP 408). #&gt; - The client did not produce a request within the time that the server was prepared #&gt; to wait. The client MAY repeat the request without modifications at any later time. Stubbing requests and set HTTP error expectation library(fauxpas) stub_request(&quot;get&quot;, &quot;https://httpbin.org/get?a=b&quot;) %&gt;% to_raise(HTTPBadRequest) x &lt;- HttpClient$new(url = &quot;https://httpbin.org&quot;) x$get(&#39;get&#39;, query = list(a = &quot;b&quot;)) #&gt; Error: Bad Request (HTTP 400). #&gt; - The request could not be understood by the server due to malformed syntax. #&gt; The client SHOULD NOT repeat the request without modifications. "],
["webmockr-testing.html", "Chapter 5 testing", " Chapter 5 testing library(&quot;webmockr&quot;) library(&quot;crul&quot;) library(&quot;testthat&quot;) stub_registry_clear() # make a stub stub_request(&quot;get&quot;, &quot;https://httpbin.org/get&quot;) %&gt;% to_return(body = &quot;success!&quot;, status = 200) #&gt; &lt;webmockr stub&gt; #&gt; method: get #&gt; uri: https://httpbin.org/get #&gt; with: #&gt; query: #&gt; body: #&gt; request_headers: #&gt; to_return: #&gt; status: 200 #&gt; body: success! #&gt; response_headers: #&gt; should_timeout: FALSE #&gt; should_raise: FALSE # check that it&#39;s in the stub registry stub_registry() #&gt; &lt;webmockr stub registry&gt; #&gt; Registered Stubs #&gt; GET: https://httpbin.org/get | to_return: with body &quot;success!&quot; with status 200 # make the request z &lt;- crul::HttpClient$new(url = &quot;https://httpbin.org&quot;)$get(&quot;get&quot;) # run tests (nothing returned means it passed) expect_is(z, &quot;HttpResponse&quot;) expect_equal(z$status_code, 200) expect_equal(z$parse(&quot;UTF-8&quot;), &quot;success!&quot;) "],
["webmockr-utilities.html", "Chapter 6 utilities 6.1 Managing stubs 6.2 Managing stubs 6.3 Managing requests", " Chapter 6 utilities library(&quot;webmockr&quot;) 6.1 Managing stubs enable() enabled() disable() httr_mock() 6.2 Managing stubs stub_registry() stub_registry_clear() remove_request_stub() 6.3 Managing requests request_registry() "],
["vcr-intro.html", "Chapter 7 Caching HTTP requests 7.1 Terminology 7.2 Basic usage", " Chapter 7 Caching HTTP requests some intro text … 7.1 Terminology http: hyptertext transfer protocol vcr: the name comes from the idea that we want to record something and play it back later, like a VCR cassette: A thing to record HTTP interactions to. Right now the only option is file system, but in the future could be other things, e.g. a key-value store like Redis Persister: defines how to save requests - currently only option is the file system Serializers: defines how to serialize the HTTP response; that is, how the data is stored on whatever the persister is (right now only file system). Currently only option is YAML; other options in the future could include e.g. JSON insert cassette: create a cassette (all HTTP interactions will be recorded to this cassette). once a cassette is inserted, we don’t allow insertion of additional cassettes eject cassette: eject the cassette (no longer recording to that cassette). however, if any interactions were written to disk, those are still stored there replay: refers to using a cached result of an http request that was recorded earlier recording: this means you’ve set vcr in a mode in which we can record HTTP interactions. sometimes recording can be not possible given user configuration or otherwise 7.2 Basic usage library(vcr) library(crul) cli &lt;- crul::HttpClient$new(url = &quot;https://api.crossref.org&quot;) system.time( use_cassette(name = &quot;helloworld&quot;, { cli$get(&quot;works&quot;, query = list(rows = 3)) }) ) #&gt; user system elapsed #&gt; 0.094 0.010 3.975 The request gets recorded, and all subsequent requests of the same form used the cached HTTP response, and so are much faster system.time( use_cassette(name = &quot;helloworld&quot;, { cli$get(&quot;works&quot;, query = list(rows = 3)) }) ) #&gt; user system elapsed #&gt; 0.052 0.001 0.057 Importantly, your unit test deals with the same inputs and the same outputs - but behind the scenes you use a cached HTTP resonse - thus, your tests run faster. The cached response looks something like (condensed for brevity): http_interactions: - request: method: get uri: https://api.crossref.org/works?rows=3 body: encoding: &#39;&#39; string: &#39;&#39; headers: User-Agent: libcurl/7.54.0 r-curl/3.2 crul/0.5.2 Accept-Encoding: gzip, deflate Accept: application/json, text/xml, application/xml, */* response: status: status_code: &#39;200&#39; message: OK explanation: Request fulfilled, document follows headers: status: HTTP/1.1 200 OK content-type: application/json;charset=UTF-8 vary: Accept access-control-allow-origin: &#39;*&#39; access-control-allow-headers: X-Requested-With content-length: &#39;5360&#39; server: http-kit date: Sat, 28 Apr 2018 15:12:29 GMT x-rate-limit-limit: &#39;50&#39; x-rate-limit-interval: 1s connection: close body: encoding: UTF-8 string: &#39;{&quot;status&quot;:&quot;ok&quot;,&quot;message-type&quot;:&quot;work-list&quot;,&quot;message-version&quot;:&quot;1.0.0&quot;,&quot;message&quot;:{&quot;facets&quot;:{},&quot;total-results&quot;:96454147,&quot;items&quot;:[{&quot;indexed&quot;:{&quot;date-parts&quot;:[[2017,10,23]],&quot;date-time&quot;:&quot;2017-10-23T19:27:25Z&quot;,&quot;timestamp&quot;:1508786845330},&quot;reference-count&quot;:0,&quot;publisher&quot;:&quot;Elsevier BV&quot;,&quot;issue&quot;:&quot;3&quot;,&quot;license&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/www.elsevier.com\\/tdm\\/userlicense\\/1.0\\/&quot;,&quot;start&quot;:{&quot;date-parts&quot;:[[1999,10,1]],&quot;date-time&quot;:&quot;1999-10-01T00:00:00Z&quot;,&quot;timestamp&quot;:938736000000},&quot;delay-in-days&quot;:0,&quot;content-version&quot;:&quot;tdm&quot;}],&quot;content-domain&quot;:{&quot;domain&quot;:[],&quot;crossmark-restriction&quot;:false},&quot;short-container-title&quot;:[&quot;Progress in Planning&quot;],&quot;published-print&quot;:{&quot;date-parts&quot;:[[1999,10]]},&quot;DOI&quot;:&quot;10.1016\\/s0305-9006(99)00007-0&quot;,&quot;type&quot;:&quot;journal-article&quot;,&quot;created&quot;:{&quot;date-parts&quot;:[[2002,7,26]],&quot;date-time&quot;:&quot;2002-07-26T00:11:38Z&quot;,&quot;timestamp&quot;:1027642298000},&quot;page&quot;:&quot;vii&quot;,&quot;source&quot;:&quot;Crossref&quot;,&quot;is-referenced-by-count&quot;:0,&quot;title&quot;:[&quot;Editorial&quot;],&quot;prefix&quot;:&quot;10.1016&quot;,&quot;volume&quot;:&quot;52&quot;,&quot;member&quot;:&quot;78&quot;,&quot;container-title&quot;:[&quot;Progress in Planning&quot;],&quot;link&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900699000070?httpAccept=text\\/xml&quot;,&quot;content-type&quot;:&quot;text\\/xml&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;},{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900699000070?httpAccept=text\\/plain&quot;,&quot;content-type&quot;:&quot;text\\/plain&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;}],&quot;deposited&quot;:{&quot;date-parts&quot;:[[2015,9,9]],&quot;date-time&quot;:&quot;2015-09-09T06:07:58Z&quot;,&quot;timestamp&quot;:1441778878000},&quot;score&quot;:1.0,&quot;issued&quot;:{&quot;date-parts&quot;:[[1999,10]]},&quot;references-count&quot;:0,&quot;alternative-id&quot;:[&quot;S0305900699000070&quot;],&quot;URL&quot;:&quot;http:\\/\\/dx.doi.org\\/10.1016\\/s0305-9006(99)00007-0&quot;,&quot;ISSN&quot;:[&quot;0305-9006&quot;],&quot;issn-type&quot;:[{&quot;value&quot;:&quot;0305-9006&quot;,&quot;type&quot;:&quot;print&quot;}],&quot;subject&quot;:[&quot;Geography, Planning and Development&quot;]},{&quot;indexed&quot;:{&quot;date-parts&quot;:[[2017,10,23]],&quot;date-time&quot;:&quot;2017-10-23T19:27:25Z&quot;,&quot;timestamp&quot;:1508786845347},&quot;reference-count&quot;:0,&quot;publisher&quot;:&quot;Elsevier BV&quot;,&quot;issue&quot;:&quot;4&quot;,&quot;license&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/www.elsevier.com\\/tdm\\/userlicense\\/1.0\\/&quot;,&quot;start&quot;:{&quot;date-parts&quot;:[[1998,12,1]],&quot;date-time&quot;:&quot;1998-12-01T00:00:00Z&quot;,&quot;timestamp&quot;:912470400000},&quot;delay-in-days&quot;:0,&quot;content-version&quot;:&quot;tdm&quot;}],&quot;content-domain&quot;:{&quot;domain&quot;:[],&quot;crossmark-restriction&quot;:false},&quot;short-container-title&quot;:[&quot;Progress in Planning&quot;],&quot;published-print&quot;:{&quot;date-parts&quot;:[[1998,12]]},&quot;DOI&quot;:&quot;10.1016\\/s0305-9006(98)00020-8&quot;,&quot;type&quot;:&quot;journal-article&quot;,&quot;created&quot;:{&quot;date-parts&quot;:[[2002,7,26]],&quot;date-time&quot;:&quot;2002-07-26T00:11:38Z&quot;,&quot;timestamp&quot;:1027642298000},&quot;page&quot;:&quot;VI&quot;,&quot;source&quot;:&quot;Crossref&quot;,&quot;is-referenced-by-count&quot;:0,&quot;title&quot;:[&quot;Preface&quot;],&quot;prefix&quot;:&quot;10.1016&quot;,&quot;volume&quot;:&quot;50&quot;,&quot;author&quot;:[{&quot;given&quot;:&quot;Maurice&quot;,&quot;family&quot;:&quot;Yeats&quot;,&quot;affiliation&quot;:[]}],&quot;member&quot;:&quot;78&quot;,&quot;container-title&quot;:[&quot;Progress in Planning&quot;],&quot;link&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900698000208?httpAccept=text\\/xml&quot;,&quot;content-type&quot;:&quot;text\\/xml&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;},{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900698000208?httpAccept=text\\/plain&quot;,&quot;content-type&quot;:&quot;text\\/plain&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;}],&quot;deposited&quot;:{&quot;date-parts&quot;:[[2015,9,9]],&quot;date-time&quot;:&quot;2015-09-09T06:07:58Z&quot;,&quot;timestamp&quot;:1441778878000},&quot;score&quot;:1.0,&quot;issued&quot;:{&quot;date-parts&quot;:[[1998,12]]},&quot;references-count&quot;:0,&quot;alternative-id&quot;:[&quot;S0305900698000208&quot;],&quot;URL&quot;:&quot;http:\\/\\/dx.doi.org\\/10.1016\\/s0305-9006(98)00020-8&quot;,&quot;ISSN&quot;:[&quot;0305-9006&quot;],&quot;issn-type&quot;:[{&quot;value&quot;:&quot;0305-9006&quot;,&quot;type&quot;:&quot;print&quot;}],&quot;subject&quot;:[&quot;Geography, Planning and Development&quot;]},{&quot;indexed&quot;:{&quot;date-parts&quot;:[[2017,10,23]],&quot;date-time&quot;:&quot;2017-10-23T19:27:25Z&quot;,&quot;timestamp&quot;:1508786845389},&quot;reference-count&quot;:24,&quot;publisher&quot;:&quot;Elsevier BV&quot;,&quot;issue&quot;:&quot;1&quot;,&quot;license&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/www.elsevier.com\\/tdm\\/userlicense\\/1.0\\/&quot;,&quot;start&quot;:{&quot;date-parts&quot;:[[1999,1,1]],&quot;date-time&quot;:&quot;1999-01-01T00:00:00Z&quot;,&quot;timestamp&quot;:915148800000},&quot;delay-in-days&quot;:0,&quot;content-version&quot;:&quot;tdm&quot;}],&quot;content-domain&quot;:{&quot;domain&quot;:[],&quot;crossmark-restriction&quot;:false},&quot;short-container-title&quot;:[&quot;Powder Technology&quot;],&quot;published-print&quot;:{&quot;date-parts&quot;:[[1999,1]]},&quot;DOI&quot;:&quot;10.1016\\/s0032-5910(98)00119-3&quot;,&quot;type&quot;:&quot;journal-article&quot;,&quot;created&quot;:{&quot;date-parts&quot;:[[2002,7,26]],&quot;date-time&quot;:&quot;2002-07-26T00:11:20Z&quot;,&quot;timestamp&quot;:1027642280000},&quot;page&quot;:&quot;17-30&quot;,&quot;source&quot;:&quot;Crossref&quot;,&quot;is-referenced-by-count&quot;:0,&quot;title&quot;:[&quot;Load diversion by embedding in crushed salt&quot;],&quot;prefix&quot;:&quot;10.1016&quot;,&quot;volume&quot;:&quot;101&quot;,&quot;author&quot;:[{&quot;given&quot;:&quot;W.&quot;,&quot;family&quot;:&quot;Feuser&quot;,&quot;affiliation&quot;:[]},{&quot;given&quot;:&quot;H.&quot;,&quot;family&quot;:&quot;Vijgen&quot;,&quot;affiliation&quot;:[]},{&quot;given&quot;:&quot;E.&quot;,&quot;family&quot;:&quot;Barnert&quot;,&quot;affiliation&quot;:[]}],&quot;member&quot;:&quot;78&quot;,&quot;container-title&quot;:[&quot;Powder Technology&quot;],&quot;link&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0032591098001193?httpAccept=text\\/xml&quot;,&quot;content-type&quot;:&quot;text\\/xml&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;},{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0032591098001193?httpAccept=text\\/plain&quot;,&quot;content-type&quot;:&quot;text\\/plain&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;}],&quot;deposited&quot;:{&quot;date-parts&quot;:[[2017,6,15]],&quot;date-time&quot;:&quot;2017-06-15T02:22:06Z&quot;,&quot;timestamp&quot;:1497493326000},&quot;score&quot;:1.0,&quot;issued&quot;:{&quot;date-parts&quot;:[[1999,1]]},&quot;references-count&quot;:24,&quot;alternative-id&quot;:[&quot;S0032591098001193&quot;],&quot;URL&quot;:&quot;http:\\/\\/dx.doi.org\\/10.1016\\/s0032-5910(98)00119-3&quot;,&quot;ISSN&quot;:[&quot;0032-5910&quot;],&quot;issn-type&quot;:[{&quot;value&quot;:&quot;0032-5910&quot;,&quot;type&quot;:&quot;print&quot;}],&quot;subject&quot;:[&quot;General Chemical Engineering&quot;]}],&quot;items-per-page&quot;:3,&quot;query&quot;:{&quot;start-index&quot;:0,&quot;search-terms&quot;:null}}}&#39; recorded_at: 2018-04-28 15:12:29 GMT recorded_with: vcr/0.0.8.9521, webmockr/0.2.2.9119, crul/0.5.2 All components of both the request and response are preserved, so that the HTTP client (in this case crul) can reconstruct its own response just as it would if it wasn’t using vcr. "],
["vcr-configuration.html", "Chapter 8 vcr configuration 8.1 Get your configuration 8.2 Set configuration variables 8.3 Re-set to defaults 8.4 dir - directory of where cassettes are stored 8.5 record - record mode 8.6 match_requests_on - customize how vcr matches requests 8.7 allow_unused_http_interactions - Allow HTTP connections when no cassette 8.8 serialize_with - which serializer to use 8.9 persist_with - which persister to use 8.10 ignore requests 8.11 uri_parser - which uri parser to use 8.12 preserve_exact_body_bytes 8.13 allow_http_connections_when_no_cassette", " Chapter 8 vcr configuration vcr configuration library(&quot;vcr&quot;) 8.1 Get your configuration Use vcr_configuration() to get the current configuration vcr_configuration() #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE You can get the default configuration variables via vcr_config_defaults() vcr_config_defaults() #&gt; $dir #&gt; [1] &quot;.&quot; #&gt; #&gt; $record #&gt; [1] &quot;once&quot; #&gt; #&gt; $match_requests_on #&gt; [1] &quot;method&quot; &quot;uri&quot; #&gt; #&gt; $allow_unused_http_interactions #&gt; [1] TRUE #&gt; #&gt; $serialize_with #&gt; [1] &quot;yaml&quot; #&gt; #&gt; $persist_with #&gt; [1] &quot;FileSystem&quot; #&gt; #&gt; $ignore_hosts #&gt; NULL #&gt; #&gt; $ignore_localhost #&gt; [1] FALSE #&gt; #&gt; $ignore_request #&gt; NULL #&gt; #&gt; $uri_parser #&gt; [1] &quot;crul::url_parse&quot; #&gt; #&gt; $preserve_exact_body_bytes #&gt; [1] FALSE #&gt; #&gt; $turned_off #&gt; [1] FALSE #&gt; #&gt; $ignore_cassettes #&gt; [1] FALSE #&gt; #&gt; $re_record_interval #&gt; NULL #&gt; #&gt; $clean_outdated_http_interactions #&gt; NULL #&gt; #&gt; $allow_http_connections_when_no_cassette #&gt; [1] FALSE #&gt; #&gt; $cassettes #&gt; list() #&gt; #&gt; $linked_context #&gt; NULL #&gt; #&gt; $log #&gt; [1] FALSE #&gt; #&gt; $log_opts #&gt; $log_opts$file #&gt; [1] &quot;vcr.log&quot; #&gt; #&gt; $log_opts$log_prefix #&gt; [1] &quot;Cassette&quot; #&gt; #&gt; #&gt; $filter_sensitive_data #&gt; NULL These defaults are set when you load vcr - you can override any of them as described below. 8.2 Set configuration variables Use vcr_configure() to set configuration variables. For example, set a single variable: vcr_configure( dir = &quot;foobar/vcr_cassettes&quot; ) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: foobar/vcr_cassettes #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE Or many at once: vcr_configure( dir = &quot;foobar/vcr_cassettes&quot;, record = &quot;all&quot; ) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: foobar/vcr_cassettes #&gt; Record: all #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.3 Re-set to defaults vcr_configure_reset() #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.4 dir - directory of where cassettes are stored vcr_configure(dir = &quot;new/path&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: new/path #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.5 record - record mode One of: ‘all’, ‘none’, ‘new_episodes’, ‘once’. See ?recording for info on the options vcr_configure(record = &quot;new_episodes&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: new_episodes #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.6 match_requests_on - customize how vcr matches requests vcr_configure(match_requests_on = c(&#39;query&#39;, &#39;headers&#39;)) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: query, headers #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.7 allow_unused_http_interactions - Allow HTTP connections when no cassette Default is TRUE, and thus does not error when http interactions are unused. You can set to FALSE in which case vcr errors when a cassette is ejected and not all http interactions have been used. vcr_configure(allow_unused_http_interactions = FALSE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.8 serialize_with - which serializer to use Right now the only option is yaml vcr_configure(serialize_with = &quot;yaml&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.9 persist_with - which persister to use Right now the only option is FileSystem vcr_configure(persist_with = &quot;FileSystem&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.10 ignore requests 8.10.1 ignore_hosts - specify particular hosts to ignore vcr_configure(ignore_hosts = &quot;google.com&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.10.2 ignore_localhost - ignore all localhost flavors vcr_configure(ignore_localhost = TRUE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.10.3 ignore_request - ignore any request for which function is true vcr_configure(ignore_request = function(x) x == 5) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.11 uri_parser - which uri parser to use By default we use httr::parse_url, but you can use a different one. Remember to pass in the function quoted, and namespaced. vcr_configure(uri_parser = &quot;urltools::url_parse&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: urltools::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 8.12 preserve_exact_body_bytes Some HTTP servers are not well-behaved and respond with invalid data. Set preserve_exact_body_bytes to TRUE to base64 encode the result body in order to preserve the bytes exactly as-is. vcr does not do this by default, since base64-encoding the string removes the human readibility of the cassette. vcr_configure(preserve_exact_body_bytes = TRUE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: TRUE #&gt; Logging?: FALSE 8.13 allow_http_connections_when_no_cassette Determines how vcr treats HTTP requests that are made when no cassette is in use. When TRUE, requests made when there is no vcr cassette in use will be allowed. When FALSE (default), an [UnhandledHTTPRequestError] error will be raised for any HTTP request made when there is no cassette in use vcr_configure(allow_http_connections_when_no_cassette = TRUE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE "],
["record-modes.html", "Chapter 9 record modes 9.1 once 9.2 none 9.3 new_episodes 9.4 all", " Chapter 9 record modes Record modes dictate under what circumstances http requests/responses are recorded to cassettes (disk). Set the recording mode with the parameter record in the use_cassette() and insert_cassette() functions. 9.1 once The once record mode will: Replay previously recorded interactions. Record new interactions if there is no cassette file. Cause an error to be raised for new requests if there is a cassette file. It is similar to the new_episodes record mode, but will prevent new, unexpected requests from being made (i.e. because the request URI changed or whatever). once is the default record mode, used when you do not set one. 9.2 none The none record mode will: Replay previously recorded interactions. Cause an error to be raised for any new requests. This is useful when your code makes potentially dangerous HTTP requests. The none record mode guarantees that no new HTTP requests will be made. 9.3 new_episodes The new_episodes record mode will: Record new interactions. Replay previously recorded interactions. It is similar to the once record mode, but will always record new interactions, even if you have an existing recorded one that is similar (but not identical, based on the match_request_on option). 9.4 all The all record mode will: Record new interactions. Never replay previously recorded interactions. This can be temporarily used to force vcr to re-record a cassette (i.e. to ensure the responses are not out of date) or can be used when you simply want to log all HTTP requests. "],
["request-matching.html", "Chapter 10 request matching 10.1 matching on method 10.2 matching on uri 10.3 matching on host 10.4 matching on path 10.5 matching on query string 10.6 matching on body 10.7 matching on headers 10.8 Playback repeats", " Chapter 10 request matching There are a number of options, some of which are on by default, some of which can be used together, and some alone. 10.1 matching on method Use the method request matcher to match requests on the HTTP method (i.e. GET, POST, PUT, DELETE, etc). You will generally want to use this matcher. The method matcher is used (along with the uri matcher) by default if you do not specify how requests should match. 10.2 matching on uri Use the uri request matcher to match requests on the request URI. The uri matcher is used (along with the method matcher) by default if you do not specify how requests should match. 10.3 matching on host Use the host request matcher to match requests on the request host. You can use this (alone, or in combination with path) as an alternative to uri so that non-deterministic portions of the URI are not considered as part of the request matching. 10.4 matching on path Use the path request matcher to match requests on the path portion of the request URI. You can use this (alone, or in combination with host) as an alternative to uri so that non-deterministic portions of the URI 10.5 matching on query string Use the query request matcher to match requests on the query string portion of the request URI. You can use this (alone, or in combination with others) as an alternative to uri so that non-deterministic portions of the URI are not considered as part of the request matching. 10.6 matching on body Use the body request matcher to match requests on the request body. 10.7 matching on headers Use the headers request matcher to match requests on the request headers. 10.8 Playback repeats still in progress … "],
["logging.html", "Chapter 11 logging 11.1 Setup logging 11.2 The log file", " Chapter 11 logging Use logging to set an IO-like object that vcr will log output to. This is a useful way to troubleshoot what vcr is doing. 11.1 Setup logging To set up logging, see ?vcr_logging use vcr_configure() vcr::vcr_configure( log = TRUE, log_opts = list(file = &quot;vcr.log&quot;, log_prefix = &quot;Cassette&quot;, date = TRUE) ) The log parameter is a boolean to indicate whether vcr should log or not The log_opts parameter is a named list with various options: file: the log file path (it does not get put in the cassette directory, but is at whatever this path is) log_prefix: prefix to put in each log entry. the default is Cassette date: whether to include a time stamp in each log entry or not. format is YYYY-MM-DD HH:MM:SS 11.2 The log file The following is an example log file: [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Init. HTTPInteractionList w/ request matchers [method, uri] &amp; 1 interaction(s): { get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 =&gt; ??? [{&quot;AphiaID&quot;:297110,&quot;url&quot;:&quot;http:\\/\\/www.marinespecies.org\\/aphia.php?p=taxdetails } [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Initialized with options: {name: foobar, record: once, serialize_with: yaml, persist_with: FileSystem, match_requests_on: c(&quot;method&quot;, &quot;uri&quot;), update_content_length_header: FALSE, allow_playback_repeats: FALSE, preserve_exact_body_bytes: FALSE} [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Handling request: get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 (disabled: FALSE) [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Checking if {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} matches {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} using matchers: [method, uri] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - method matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - uri matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Identified request type: (stubbed_by_vcr) for get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Checking if {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} matches {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} using matchers: [method, uri] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - method matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - uri matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Found matching interaction for get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 at index 1: ??? [{&quot;AphiaID&quot;:297110,&quot;url&quot;:&quot;http:\\/\\/www.marinespecies.org\\/aphia.php?p=taxdetails Internally vcr logs certain actions that we think are important steps in the process, including: initializing an HTTPInteractionList object that holds HTTP interactions initializing a Cassette with whatever options the user passes in declaring what request is being handled what request is being checked whether there is a match found or not when an interaction is recorded, or pulled from a stub, etc. If you turn off the date, you won’t get date entries: vcr::vcr_configure( log = TRUE, log_opts = list(file = &quot;vcr.log&quot;, log_prefix = &quot;Cassette&quot;, date = FALSE) ) [Cassette: &#39;foobar&#39;] - {{message}} And you can change the prefix from Cassette to something else: vcr::vcr_configure( log = TRUE, log_opts = list(file = &quot;vcr.log&quot;, log_prefix = &quot;Unicorn&quot;, date = FALSE) ) [Unicorn: &#39;foobar&#39;] - {{message}} "],
["security.html", "Chapter 12 security 12.1 API keys and such 12.2 Other security", " Chapter 12 security 12.1 API keys and such The configuration parameter filter_sensitive_data accepts a named list. Each element in the list should be of the following format: thing_to_replace_it_with = thing_to_replace We replace all instances of thing_to_replace with thing_to_replace_it_with. Before recording (writing to a cassette) we do the replacement and then when reading from the cassette we do the reverse replacement to get back to the real data. The before record replacement happens in an internal function write_interactions(), while before playback replacement happens in internal function YAML$deserialize_path() vcr_configure( filter_sensitive_data = list(&quot;&lt;&lt;&lt;my_api_key&gt;&gt;&gt;&quot; = Sys.getenv(&#39;API_KEY&#39;)) ) You want to make the string that replaces your sensitive string something that won’t be easily found elsewhere in the response body/headers/etc. It’s a good idea to not in place of thing_to_replace put your actual sensitive key thing, because that defeats the purpose of trying to protect your private data. This is why we highly recommend setting your API keys as environment variables, then you can as seen above just put a call to Sys.getenv(), which we’ll use internally to get your key, find it anywhere in the HTTP responses, and replace it with your placeholder string. The reason you want to do this is because you may on purpose or on accident push your cassettes to the public web, and when that happens you don’t want your private keys in those cassettes. Note that the way this is implemented in vcr is not super elegant and is not general with respect to the serializer. We only support YAML serializing right now, but when we support other serializers we’ll need to change the implementation. 12.2 Other security Let us know about any other security concerns! Surely there’s things we haven’t considered yet. "],
["escape-hatches.html", "Chapter 13 escape hatches 13.1 lightswitch: vcr, webmockr and their on/off states 13.2 turned_off 13.3 turn_off", " Chapter 13 escape hatches There’s many different scenarios for using vcr, some of which are that you have vcr loaded but you want to still make real HTTP requests. The following are different ways to allow real HTTP requests. 13.1 lightswitch: vcr, webmockr and their on/off states After loading vcr, webmockr is not loaded, thus real HTTP requests are allowed. library(vcr) After loading webmockr you can still make real HTTP requests. library(webmockr) But after turning mocking on you can’t make real requests crul::mock() # OR webmockr::enable() And you’ll get errors that come from webmockr when attempting real HTTP requests HttpClient$new(url = &quot;https://httpbin.org/get&quot;)$get() #&gt; Error: Real HTTP connections are disabled. #&gt; Unregistered request: GET https://httpbin.org/get with headers {Accept-Encoding: gzip, deflate} #&gt; #&gt; You can stub this request with the following snippet: #&gt; #&gt; stub_request(&#39;get&#39;, uri = &#39;https://httpbin.org/get&#39;) %&gt;% #&gt; wi_th(headers = list(&#39;Accept-Encoding&#39; = &#39;gzip, deflate&#39;)) You can have vcr loaded but if you’re not using use_casette 13.2 turned_off turned_off() lets you temporarily make a real HTTP request without completely turning vcr off, unloading it, etc. What happens internally is we turn off vcr, run your code block, then on exit turn vcr back on - such that vcr is onl turned off for the duration of your code block running. Even if your code block errors, vcr will be turned back on due to use of on.exit(turn_on()) library(vcr) library(crul) turned_off({ res &lt;- HttpClient$new(url = &quot;https://httpbin.org/get&quot;)$get() }) res #&gt; &lt;crul response&gt; #&gt; url: https://httpbin.org/get #&gt; request_headers: #&gt; User-Agent: libcurl/7.54.0 r-curl/3.2 crul/0.5.2 #&gt; Accept-Encoding: gzip, deflate #&gt; Accept: application/json, text/xml, application/xml, */* #&gt; response_headers: #&gt; status: HTTP/1.1 200 OK #&gt; server: nginx #&gt; date: Fri, 27 Apr 2018 23:22:44 GMT #&gt; content-type: application/json #&gt; content-length: 330 #&gt; connection: keep-alive #&gt; access-control-allow-origin: * #&gt; access-control-allow-credentials: true #&gt; x-powered-by: Flask #&gt; x-processed-time: 0 #&gt; status: 200 13.3 turn_off "],
["gotchas.html", "Chapter 14 gotchas 14.1 Correct line identification", " Chapter 14 gotchas There’s a few things to watch out for when using vcr. Security: Don’t put your secure API keys, tokens, etc. on the public web. See the Security chapter (12) Dates: Be careful when using dates in tests with vcr. e.g. if you generate todays date, and pass that in to a function in your package that uses that date for an HTTP request, the date will be different from the one in the matching cassette, causing a vcr failure. HTTP errors: It’s a good idea to test failure behavior of a web service in your test suite. Sometimes vcr can handle that and sometimes it cannot. Open any issues about this because ideally i think vcr could handle all cases of HTTP failures. Very large response bodies: A few things about large response bodies. First, vcr may give you trouble with very large response bodies as we’ve see yaml parsing problems already. Second, large response bodies means large cassettes on disk - so just be aware of the file size if that’s something that matters to you. Third, large response bodies will take longer to load into R, so you may still have a multi second test run even though the test is using a cached HTTP response. Encoding: We haven’t dealt with encoding much yet at all, so we’re likely to run into encoding issues. One blunt instrument for this for now is to set preserve_exact_body_bytes = TRUE when running vcr::use_cassette() or vcr::insert_cassette(), which stores the response body as base64. devtools::check vs. devtools::test: At least one user has reported vcr not working as expected when using devtools::test() - but if they used devtools::check() vcr worked as expected. We haven’t dug into why this would be. Do report it if you run into this problem. 14.1 Correct line identification To get the actual lines where failures occur, you can wrap the test_that block in a use_cassette() block: library(testthat) vcr::use_cassette(&quot;rl_citation&quot;, { test_that(&quot;my test&quot;, { aa &lt;- rl_citation() expect_is(aa, &quot;character&quot;) expect_match(aa, &quot;IUCN&quot;) expect_match(aa, &quot;www.iucnredlist.org&quot;) }) }) OR put the use_cassette() block on the inside, but make sure to put testthat expectations outside of the use_cassette() block: library(testthat) test_that(&quot;my test&quot;, { vcr::use_cassette(&quot;rl_citation&quot;, { aa &lt;- rl_citation() }) expect_is(aa, &quot;character&quot;) expect_match(aa, &quot;IUCN&quot;) expect_match(aa, &quot;www.iucnredlist.org&quot;) }) Do not wrap the use_cassette() block inside your test_that() block with testthat expectations inside the use_cassette() block, as you’ll only get the line number that the use_cassette() block starts on on failures. "],
["session-info.html", "Chapter 15 session info", " Chapter 15 session info Session info for this book sessioninfo::session_info() #&gt; ─ Session info ────────────────────────────────────────────────────────── #&gt; setting value #&gt; version R version 3.6.0 Patched (2019-04-30 r76446) #&gt; os macOS Mojave 10.14.5 #&gt; system x86_64, darwin15.6.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz US/Pacific #&gt; date 2019-06-13 #&gt; #&gt; ─ Packages ────────────────────────────────────────────────────────────── #&gt; package * version date lib source #&gt; assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.0) #&gt; base64enc 0.1-3 2015-07-28 [1] CRAN (R 3.6.0) #&gt; bookdown 0.11 2019-05-28 [1] CRAN (R 3.6.0) #&gt; cli 1.1.0 2019-03-19 [1] CRAN (R 3.6.0) #&gt; crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.0) #&gt; crul * 0.7.4.9310 2019-06-13 [1] local #&gt; curl 3.3 2019-01-10 [1] CRAN (R 3.6.0) #&gt; digest 0.6.19 2019-05-20 [1] CRAN (R 3.6.0) #&gt; evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.0) #&gt; fauxpas 0.2.0 2018-03-01 [1] CRAN (R 3.6.0) #&gt; htmltools 0.3.6 2017-04-28 [1] CRAN (R 3.6.0) #&gt; httpcode 0.2.0 2016-11-14 [1] CRAN (R 3.6.0) #&gt; httr 1.4.0 2018-12-11 [1] CRAN (R 3.6.0) #&gt; jsonlite 1.6 2018-12-07 [1] CRAN (R 3.6.0) #&gt; knitr 1.23 2019-05-18 [1] CRAN (R 3.6.0) #&gt; lazyeval 0.2.2 2019-03-15 [1] CRAN (R 3.6.0) #&gt; magrittr 1.5 2014-11-22 [1] CRAN (R 3.6.0) #&gt; R6 2.4.0 2019-02-14 [1] CRAN (R 3.6.0) #&gt; Rcpp 1.0.1 2019-03-17 [1] CRAN (R 3.6.0) #&gt; rlang 0.3.99.9003 2019-06-12 [1] Github (r-lib/rlang@2276162) #&gt; rmarkdown 1.13 2019-05-22 [1] CRAN (R 3.6.0) #&gt; rstudioapi 0.10 2019-03-19 [1] CRAN (R 3.6.0) #&gt; sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.0) #&gt; stringi 1.4.3 2019-03-12 [1] CRAN (R 3.6.0) #&gt; stringr 1.4.0 2019-02-10 [1] CRAN (R 3.6.0) #&gt; testthat * 2.1.1 2019-04-23 [1] CRAN (R 3.6.0) #&gt; triebeard 0.3.0 2016-08-04 [1] CRAN (R 3.6.0) #&gt; urltools 1.7.3 2019-04-14 [1] CRAN (R 3.6.0) #&gt; vcr * 0.2.6.9100 2019-06-13 [1] local #&gt; webmockr * 0.3.4.9100 2019-06-13 [1] local #&gt; withr 2.1.2 2018-03-15 [1] CRAN (R 3.6.0) #&gt; xfun 0.7 2019-05-14 [1] CRAN (R 3.6.0) #&gt; yaml 2.2.0 2018-07-25 [1] CRAN (R 3.6.0) #&gt; #&gt; [1] /Library/Frameworks/R.framework/Versions/3.6/Resources/library "]
]
