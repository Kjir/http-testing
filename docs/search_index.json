[
["index.html", "HTTP mocking and testing in R Chapter 1 Preamble", " HTTP mocking and testing in R built w/ vcr v0.2.0 / webmockr v0.3.0 / crul v0.7.0 / curl v3.3 built on 2019-01-12 Chapter 1 Preamble This book is intended as a detailed guide to using a particular suite of packages for HTTP mocking and testing in R code and/or packages. Info Source: https://github.com/ropensci/http-testing-book/ Issues/Bug reports: https://github.com/ropensci/http-testing-book/issues Packages crul: https://cran.rstudio.com/web/packages/crul/ webmockr: https://cran.rstudio.com/web/packages/webmockr/ vcr: https://github.com/ropensci/vcr/ curl: https://github.com/jeroen/curl/ Installation Stable version from CRAN install.packages(c(&quot;crul&quot;, &quot;webmockr&quot;, &quot;vcr&quot;)) none of crul, webmockr or vcr have native code, but an underlying dependency of all of them, curl does. See curl’s README for installation instructions in case you run into curl related problems. "],
["intro.html", "Chapter 2 Introduction 2.1 What is webmockr? 2.2 What is vcr? 2.3 Why crul? 2.4 Use cases", " Chapter 2 Introduction 2.1 What is webmockr? webmockr is an R package to help you “mock” HTTTP requests. What does mock mean? Mock refers to the fact that we’re faking the response. Here’w how it works: You “stub” a request. That is, you set rules for what HTTP request you’d like to match on You also can set rules for what you’d like to respond with, if anything (if nothing, then we give you NULL) Then you make HTTP requests, and those that match your stub will return what you requested be returned While webmockr is in use, real HTTP interactions are not allowed There is no recording interactions to disk at all, just mocked responses given as the user specifies in the R session Read more about webmockr in Section 2. 2.2 What is vcr? The short version is: vcr helps you stub HTTP requests so you don’t have to repeat HTTP requests. The main use case is for unit tests for R packages. vcr currently only works with the crul package, but we plan to make it work with httr. vcr works by hooking into webmockr. However, when webmockr finds a match, we then look for a recorded interaction on disk. If one is not found, we record the request and response. If one is found, we use that recorded interaction to construct a real response as the R client expects. Read more about webmockr in Section 3. 2.3 Why crul? crul is just one of the HTTP clients in R. It’s the one that I maintain though, so was easiest to get started with adding mocking integration. We do plan to add integration for httr in the future to both webmockr and vcr. 2.4 Use cases 2.4.1 mocking use cases one two three 2.4.2 caching use cases one two three "],
["mocking.html", "Chapter 3 Mocking HTTP Requests 3.1 xxx", " Chapter 3 Mocking HTTP Requests webmockr helps you mock your HTTP requests. 3.1 xxx library(&quot;webmockr&quot;) "],
["vcr-intro.html", "Chapter 4 Caching HTTP requests 4.1 Terminology 4.2 Basic usage", " Chapter 4 Caching HTTP requests some intro text … 4.1 Terminology http: hyptertext transfer protocol vcr: the name comes from the idea that we want to record something and play it back later, like a VCR cassette: A thing to record HTTP interactions to. Right now the only option is file system, but in the future could be other things, e.g. a key-value store like Redis Persister: defines how to save requests - currently only option is the file system Serializers: defines how to serialize the HTTP response; that is, how the data is stored on whatever the persister is (right now only file system). Currently only option is YAML; other options in the future could include e.g. JSON insert cassette: create a cassette (all HTTP interactions will be recorded to this cassette). once a cassette is inserted, we don’t allow insertion of additional cassettes eject cassette: eject the cassette (no longer recording to that cassette). however, if any interactions were written to disk, those are still stored there replay: refers to using a cached result of an http request that was recorded earlier recording: this means you’ve set vcr in a mode in which we can record HTTP interactions. sometimes recording can be not possible given user configuration or otherwise 4.2 Basic usage library(vcr) library(crul) cli &lt;- crul::HttpClient$new(url = &quot;https://api.crossref.org&quot;) system.time( use_cassette(name = &quot;helloworld&quot;, { cli$get(&quot;works&quot;, query = list(rows = 3)) }) ) #&gt; user system elapsed #&gt; 0.078 0.005 3.520 The request gets recorded, and all subsequent requests of the same form used the cached HTTP response, and so are much faster system.time( use_cassette(name = &quot;helloworld&quot;, { cli$get(&quot;works&quot;, query = list(rows = 3)) }) ) #&gt; user system elapsed #&gt; 0.034 0.001 0.036 Importantly, your unit test deals with the same inputs and the same outputs - but behind the scenes you use a cached HTTP resonse - thus, your tests run faster. The cached response looks something like (condensed for brevity): http_interactions: - request: method: get uri: https://api.crossref.org/works?rows=3 body: encoding: &#39;&#39; string: &#39;&#39; headers: User-Agent: libcurl/7.54.0 r-curl/3.2 crul/0.5.2 Accept-Encoding: gzip, deflate Accept: application/json, text/xml, application/xml, */* response: status: status_code: &#39;200&#39; message: OK explanation: Request fulfilled, document follows headers: status: HTTP/1.1 200 OK content-type: application/json;charset=UTF-8 vary: Accept access-control-allow-origin: &#39;*&#39; access-control-allow-headers: X-Requested-With content-length: &#39;5360&#39; server: http-kit date: Sat, 28 Apr 2018 15:12:29 GMT x-rate-limit-limit: &#39;50&#39; x-rate-limit-interval: 1s connection: close body: encoding: UTF-8 string: &#39;{&quot;status&quot;:&quot;ok&quot;,&quot;message-type&quot;:&quot;work-list&quot;,&quot;message-version&quot;:&quot;1.0.0&quot;,&quot;message&quot;:{&quot;facets&quot;:{},&quot;total-results&quot;:96454147,&quot;items&quot;:[{&quot;indexed&quot;:{&quot;date-parts&quot;:[[2017,10,23]],&quot;date-time&quot;:&quot;2017-10-23T19:27:25Z&quot;,&quot;timestamp&quot;:1508786845330},&quot;reference-count&quot;:0,&quot;publisher&quot;:&quot;Elsevier BV&quot;,&quot;issue&quot;:&quot;3&quot;,&quot;license&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/www.elsevier.com\\/tdm\\/userlicense\\/1.0\\/&quot;,&quot;start&quot;:{&quot;date-parts&quot;:[[1999,10,1]],&quot;date-time&quot;:&quot;1999-10-01T00:00:00Z&quot;,&quot;timestamp&quot;:938736000000},&quot;delay-in-days&quot;:0,&quot;content-version&quot;:&quot;tdm&quot;}],&quot;content-domain&quot;:{&quot;domain&quot;:[],&quot;crossmark-restriction&quot;:false},&quot;short-container-title&quot;:[&quot;Progress in Planning&quot;],&quot;published-print&quot;:{&quot;date-parts&quot;:[[1999,10]]},&quot;DOI&quot;:&quot;10.1016\\/s0305-9006(99)00007-0&quot;,&quot;type&quot;:&quot;journal-article&quot;,&quot;created&quot;:{&quot;date-parts&quot;:[[2002,7,26]],&quot;date-time&quot;:&quot;2002-07-26T00:11:38Z&quot;,&quot;timestamp&quot;:1027642298000},&quot;page&quot;:&quot;vii&quot;,&quot;source&quot;:&quot;Crossref&quot;,&quot;is-referenced-by-count&quot;:0,&quot;title&quot;:[&quot;Editorial&quot;],&quot;prefix&quot;:&quot;10.1016&quot;,&quot;volume&quot;:&quot;52&quot;,&quot;member&quot;:&quot;78&quot;,&quot;container-title&quot;:[&quot;Progress in Planning&quot;],&quot;link&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900699000070?httpAccept=text\\/xml&quot;,&quot;content-type&quot;:&quot;text\\/xml&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;},{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900699000070?httpAccept=text\\/plain&quot;,&quot;content-type&quot;:&quot;text\\/plain&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;}],&quot;deposited&quot;:{&quot;date-parts&quot;:[[2015,9,9]],&quot;date-time&quot;:&quot;2015-09-09T06:07:58Z&quot;,&quot;timestamp&quot;:1441778878000},&quot;score&quot;:1.0,&quot;issued&quot;:{&quot;date-parts&quot;:[[1999,10]]},&quot;references-count&quot;:0,&quot;alternative-id&quot;:[&quot;S0305900699000070&quot;],&quot;URL&quot;:&quot;http:\\/\\/dx.doi.org\\/10.1016\\/s0305-9006(99)00007-0&quot;,&quot;ISSN&quot;:[&quot;0305-9006&quot;],&quot;issn-type&quot;:[{&quot;value&quot;:&quot;0305-9006&quot;,&quot;type&quot;:&quot;print&quot;}],&quot;subject&quot;:[&quot;Geography, Planning and Development&quot;]},{&quot;indexed&quot;:{&quot;date-parts&quot;:[[2017,10,23]],&quot;date-time&quot;:&quot;2017-10-23T19:27:25Z&quot;,&quot;timestamp&quot;:1508786845347},&quot;reference-count&quot;:0,&quot;publisher&quot;:&quot;Elsevier BV&quot;,&quot;issue&quot;:&quot;4&quot;,&quot;license&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/www.elsevier.com\\/tdm\\/userlicense\\/1.0\\/&quot;,&quot;start&quot;:{&quot;date-parts&quot;:[[1998,12,1]],&quot;date-time&quot;:&quot;1998-12-01T00:00:00Z&quot;,&quot;timestamp&quot;:912470400000},&quot;delay-in-days&quot;:0,&quot;content-version&quot;:&quot;tdm&quot;}],&quot;content-domain&quot;:{&quot;domain&quot;:[],&quot;crossmark-restriction&quot;:false},&quot;short-container-title&quot;:[&quot;Progress in Planning&quot;],&quot;published-print&quot;:{&quot;date-parts&quot;:[[1998,12]]},&quot;DOI&quot;:&quot;10.1016\\/s0305-9006(98)00020-8&quot;,&quot;type&quot;:&quot;journal-article&quot;,&quot;created&quot;:{&quot;date-parts&quot;:[[2002,7,26]],&quot;date-time&quot;:&quot;2002-07-26T00:11:38Z&quot;,&quot;timestamp&quot;:1027642298000},&quot;page&quot;:&quot;VI&quot;,&quot;source&quot;:&quot;Crossref&quot;,&quot;is-referenced-by-count&quot;:0,&quot;title&quot;:[&quot;Preface&quot;],&quot;prefix&quot;:&quot;10.1016&quot;,&quot;volume&quot;:&quot;50&quot;,&quot;author&quot;:[{&quot;given&quot;:&quot;Maurice&quot;,&quot;family&quot;:&quot;Yeats&quot;,&quot;affiliation&quot;:[]}],&quot;member&quot;:&quot;78&quot;,&quot;container-title&quot;:[&quot;Progress in Planning&quot;],&quot;link&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900698000208?httpAccept=text\\/xml&quot;,&quot;content-type&quot;:&quot;text\\/xml&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;},{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0305900698000208?httpAccept=text\\/plain&quot;,&quot;content-type&quot;:&quot;text\\/plain&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;}],&quot;deposited&quot;:{&quot;date-parts&quot;:[[2015,9,9]],&quot;date-time&quot;:&quot;2015-09-09T06:07:58Z&quot;,&quot;timestamp&quot;:1441778878000},&quot;score&quot;:1.0,&quot;issued&quot;:{&quot;date-parts&quot;:[[1998,12]]},&quot;references-count&quot;:0,&quot;alternative-id&quot;:[&quot;S0305900698000208&quot;],&quot;URL&quot;:&quot;http:\\/\\/dx.doi.org\\/10.1016\\/s0305-9006(98)00020-8&quot;,&quot;ISSN&quot;:[&quot;0305-9006&quot;],&quot;issn-type&quot;:[{&quot;value&quot;:&quot;0305-9006&quot;,&quot;type&quot;:&quot;print&quot;}],&quot;subject&quot;:[&quot;Geography, Planning and Development&quot;]},{&quot;indexed&quot;:{&quot;date-parts&quot;:[[2017,10,23]],&quot;date-time&quot;:&quot;2017-10-23T19:27:25Z&quot;,&quot;timestamp&quot;:1508786845389},&quot;reference-count&quot;:24,&quot;publisher&quot;:&quot;Elsevier BV&quot;,&quot;issue&quot;:&quot;1&quot;,&quot;license&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/www.elsevier.com\\/tdm\\/userlicense\\/1.0\\/&quot;,&quot;start&quot;:{&quot;date-parts&quot;:[[1999,1,1]],&quot;date-time&quot;:&quot;1999-01-01T00:00:00Z&quot;,&quot;timestamp&quot;:915148800000},&quot;delay-in-days&quot;:0,&quot;content-version&quot;:&quot;tdm&quot;}],&quot;content-domain&quot;:{&quot;domain&quot;:[],&quot;crossmark-restriction&quot;:false},&quot;short-container-title&quot;:[&quot;Powder Technology&quot;],&quot;published-print&quot;:{&quot;date-parts&quot;:[[1999,1]]},&quot;DOI&quot;:&quot;10.1016\\/s0032-5910(98)00119-3&quot;,&quot;type&quot;:&quot;journal-article&quot;,&quot;created&quot;:{&quot;date-parts&quot;:[[2002,7,26]],&quot;date-time&quot;:&quot;2002-07-26T00:11:20Z&quot;,&quot;timestamp&quot;:1027642280000},&quot;page&quot;:&quot;17-30&quot;,&quot;source&quot;:&quot;Crossref&quot;,&quot;is-referenced-by-count&quot;:0,&quot;title&quot;:[&quot;Load diversion by embedding in crushed salt&quot;],&quot;prefix&quot;:&quot;10.1016&quot;,&quot;volume&quot;:&quot;101&quot;,&quot;author&quot;:[{&quot;given&quot;:&quot;W.&quot;,&quot;family&quot;:&quot;Feuser&quot;,&quot;affiliation&quot;:[]},{&quot;given&quot;:&quot;H.&quot;,&quot;family&quot;:&quot;Vijgen&quot;,&quot;affiliation&quot;:[]},{&quot;given&quot;:&quot;E.&quot;,&quot;family&quot;:&quot;Barnert&quot;,&quot;affiliation&quot;:[]}],&quot;member&quot;:&quot;78&quot;,&quot;container-title&quot;:[&quot;Powder Technology&quot;],&quot;link&quot;:[{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0032591098001193?httpAccept=text\\/xml&quot;,&quot;content-type&quot;:&quot;text\\/xml&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;},{&quot;URL&quot;:&quot;http:\\/\\/api.elsevier.com\\/content\\/article\\/PII:S0032591098001193?httpAccept=text\\/plain&quot;,&quot;content-type&quot;:&quot;text\\/plain&quot;,&quot;content-version&quot;:&quot;vor&quot;,&quot;intended-application&quot;:&quot;text-mining&quot;}],&quot;deposited&quot;:{&quot;date-parts&quot;:[[2017,6,15]],&quot;date-time&quot;:&quot;2017-06-15T02:22:06Z&quot;,&quot;timestamp&quot;:1497493326000},&quot;score&quot;:1.0,&quot;issued&quot;:{&quot;date-parts&quot;:[[1999,1]]},&quot;references-count&quot;:24,&quot;alternative-id&quot;:[&quot;S0032591098001193&quot;],&quot;URL&quot;:&quot;http:\\/\\/dx.doi.org\\/10.1016\\/s0032-5910(98)00119-3&quot;,&quot;ISSN&quot;:[&quot;0032-5910&quot;],&quot;issn-type&quot;:[{&quot;value&quot;:&quot;0032-5910&quot;,&quot;type&quot;:&quot;print&quot;}],&quot;subject&quot;:[&quot;General Chemical Engineering&quot;]}],&quot;items-per-page&quot;:3,&quot;query&quot;:{&quot;start-index&quot;:0,&quot;search-terms&quot;:null}}}&#39; recorded_at: 2018-04-28 15:12:29 GMT recorded_with: vcr/0.0.8.9521, webmockr/0.2.2.9119, crul/0.5.2 All components of both the request and response are preserved, so that the HTTP client (in this case crul) can reconstruct its own response just as it would if it wasn’t using vcr. "],
["vcr-configuration.html", "Chapter 5 vcr configuration 5.1 Get your configuration 5.2 Set configuration variables 5.3 Re-set to defaults 5.4 dir - directory of where cassettes are stored 5.5 record - record mode 5.6 match_requests_on - customize how vcr matches requests 5.7 allow_unused_http_interactions - Allow HTTP connections when no cassette 5.8 serialize_with - which serializer to use 5.9 persist_with - which persister to use 5.10 ignore requests 5.11 uri_parser - which uri parser to use 5.12 preserve_exact_body_bytes 5.13 allow_http_connections_when_no_cassette", " Chapter 5 vcr configuration vcr configuration library(&quot;vcr&quot;) 5.1 Get your configuration Use vcr_configuration() to get the current configuration vcr_configuration() #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE You can get the default configuration variables via vcr_config_defaults() vcr_config_defaults() #&gt; $dir #&gt; [1] &quot;.&quot; #&gt; #&gt; $record #&gt; [1] &quot;once&quot; #&gt; #&gt; $match_requests_on #&gt; [1] &quot;method&quot; &quot;uri&quot; #&gt; #&gt; $allow_unused_http_interactions #&gt; [1] TRUE #&gt; #&gt; $serialize_with #&gt; [1] &quot;yaml&quot; #&gt; #&gt; $persist_with #&gt; [1] &quot;FileSystem&quot; #&gt; #&gt; $ignore_hosts #&gt; NULL #&gt; #&gt; $ignore_localhost #&gt; [1] FALSE #&gt; #&gt; $ignore_request #&gt; NULL #&gt; #&gt; $uri_parser #&gt; [1] &quot;crul::url_parse&quot; #&gt; #&gt; $preserve_exact_body_bytes #&gt; [1] FALSE #&gt; #&gt; $turned_off #&gt; [1] FALSE #&gt; #&gt; $ignore_cassettes #&gt; [1] FALSE #&gt; #&gt; $re_record_interval #&gt; NULL #&gt; #&gt; $clean_outdated_http_interactions #&gt; NULL #&gt; #&gt; $allow_http_connections_when_no_cassette #&gt; [1] FALSE #&gt; #&gt; $cassettes #&gt; list() #&gt; #&gt; $linked_context #&gt; NULL #&gt; #&gt; $log #&gt; [1] FALSE #&gt; #&gt; $log_opts #&gt; $log_opts$file #&gt; [1] &quot;vcr.log&quot; #&gt; #&gt; $log_opts$log_prefix #&gt; [1] &quot;Cassette&quot; #&gt; #&gt; #&gt; $filter_sensitive_data #&gt; NULL These defaults are set when you load vcr - you can override any of them as described below. 5.2 Set configuration variables Use vcr_configure() to set configuration variables. For example, set a single variable: vcr_configure( dir = &quot;foobar/vcr_cassettes&quot; ) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: foobar/vcr_cassettes #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE Or many at once: vcr_configure( dir = &quot;foobar/vcr_cassettes&quot;, record = &quot;all&quot; ) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: foobar/vcr_cassettes #&gt; Record: all #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.3 Re-set to defaults vcr_configure_reset() #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.4 dir - directory of where cassettes are stored vcr_configure(dir = &quot;new/path&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: new/path #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.5 record - record mode One of: ‘all’, ‘none’, ‘new_episodes’, ‘once’. See ?recording for info on the options vcr_configure(record = &quot;new_episodes&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: new_episodes #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.6 match_requests_on - customize how vcr matches requests vcr_configure(match_requests_on = c(&#39;query&#39;, &#39;headers&#39;)) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: query, headers #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.7 allow_unused_http_interactions - Allow HTTP connections when no cassette Default is TRUE, and thus does not error when http interactions are unused. You can set to FALSE in which case vcr errors when a cassette is ejected and not all http interactions have been used. vcr_configure(allow_unused_http_interactions = FALSE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.8 serialize_with - which serializer to use Right now the only option is yaml vcr_configure(serialize_with = &quot;yaml&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.9 persist_with - which persister to use Right now the only option is FileSystem vcr_configure(persist_with = &quot;FileSystem&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.10 ignore requests 5.10.1 ignore_hosts - specify particular hosts to ignore vcr_configure(ignore_hosts = &quot;google.com&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.10.2 ignore_localhost - ignore all localhost flavors vcr_configure(ignore_localhost = TRUE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.10.3 ignore_request - ignore any request for which function is true vcr_configure(ignore_request = function(x) x == 5) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.11 uri_parser - which uri parser to use By default we use httr::parse_url, but you can use a different one. Remember to pass in the function quoted, and namespaced. vcr_configure(uri_parser = &quot;urltools::url_parse&quot;) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: urltools::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE 5.12 preserve_exact_body_bytes Some HTTP servers are not well-behaved and respond with invalid data. Set preserve_exact_body_bytes to TRUE to base64 encode the result body in order to preserve the bytes exactly as-is. vcr does not do this by default, since base64-encoding the string removes the human readibility of the cassette. vcr_configure(preserve_exact_body_bytes = TRUE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: TRUE #&gt; Logging?: FALSE 5.13 allow_http_connections_when_no_cassette Determines how vcr treats HTTP requests that are made when no cassette is in use. When TRUE, requests made when there is no vcr cassette in use will be allowed. When FALSE (default), an [UnhandledHTTPRequestError] error will be raised for any HTTP request made when there is no cassette in use vcr_configure(allow_http_connections_when_no_cassette = TRUE) #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE #&gt; &lt;vcr configuration&gt; #&gt; Cassette Dir: . #&gt; Record: once #&gt; URI Parser: crul::url_parse #&gt; Match Requests on: method, uri #&gt; Preserve Bytes?: FALSE #&gt; Logging?: FALSE "],
["record-modes.html", "Chapter 6 record modes 6.1 once 6.2 none 6.3 new_episodes 6.4 all", " Chapter 6 record modes 6.1 once The once record mode will: Replay previously recorded interactions. Record new interactions if there is no cassette file. Cause an error to be raised for new requests if there is a cassette file. It is similar to the new_episodes record mode, but will prevent new, unexpected requests from being made (i.e. because the request URI changed or whatever). once is the default record mode, used when you do not set one. 6.2 none The none record mode will: Replay previously recorded interactions. Cause an error to be raised for any new requests. This is useful when your code makes potentially dangerous HTTP requests. The none record mode guarantees that no new HTTP requests will be made. 6.3 new_episodes The new_episodes record mode will: Record new interactions. Replay previously recorded interactions. It is similar to the once record mode, but will always record new interactions, even if you have an existing recorded one that is similar (but not identical, based on the match_request_on option). 6.4 all The all record mode will: Record new interactions. Never replay previously recorded interactions. This can be temporarily used to force VCR to re-record a cassette (i.e. to ensure the responses are not out of date) or can be used when you simply want to log all HTTP requests. "],
["request-matching.html", "Chapter 7 request matching 7.1 matching on method 7.2 matching on uri 7.3 matching on host 7.4 matching on path 7.5 matching on query string 7.6 matching on body 7.7 matching on headers 7.8 Playback repeats", " Chapter 7 request matching There are a number of options, some of which are on by default, some of which can be used together, and some alone. 7.1 matching on method Use the method request matcher to match requests on the HTTP method (i.e. GET, POST, PUT, DELETE, etc). You will generally want to use this matcher. The method matcher is used (along with the uri matcher) by default if you do not specify how requests should match. 7.2 matching on uri Use the uri request matcher to match requests on the request URI. The uri matcher is used (along with the method matcher) by default if you do not specify how requests should match. 7.3 matching on host Use the host request matcher to match requests on the request host. You can use this (alone, or in combination with path) as an alternative to uri so that non-deterministic portions of the URI are not considered as part of the request matching. 7.4 matching on path Use the path request matcher to match requests on the path portion of the request URI. You can use this (alone, or in combination with host) as an alternative to uri so that non-deterministic portions of the URI 7.5 matching on query string Use the query request matcher to match requests on the query string portion of the request URI. You can use this (alone, or in combination with others) as an alternative to uri so that non-deterministic portions of the URI are not considered as part of the request matching. 7.6 matching on body Use the body request matcher to match requests on the request body. 7.7 matching on headers Use the headers request matcher to match requests on the request headers. 7.8 Playback repeats still in progress … "],
["logging.html", "Chapter 8 logging 8.1 Setup logging 8.2 The log file", " Chapter 8 logging Use logging to set an IO-like object that vcr will log output to. This is a useful way to troubleshoot what vcr is doing. 8.1 Setup logging To set up logging, see ?vcr_logging use vcr_configure() vcr::vcr_configure( log = TRUE, log_opts = list(file = &quot;vcr.log&quot;, log_prefix = &quot;Cassette&quot;, date = TRUE) ) The log parameter is a boolean to indicate whether vcr should log or not The log_opts parameter is a named list with various options: file: the log file path (it does not get put in the cassette directory, but is at whatever this path is) log_prefix: prefix to put in each log entry. the default is Cassette date: whether to include a time stamp in each log entry or not. format is YYYY-MM-DD HH:MM:SS 8.2 The log file The following is an example log file: [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Init. HTTPInteractionList w/ request matchers [method, uri] &amp; 1 interaction(s): { get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 =&gt; ??? [{&quot;AphiaID&quot;:297110,&quot;url&quot;:&quot;http:\\/\\/www.marinespecies.org\\/aphia.php?p=taxdetails } [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Initialized with options: {name: foobar, record: once, serialize_with: yaml, persist_with: FileSystem, match_requests_on: c(&quot;method&quot;, &quot;uri&quot;), update_content_length_header: FALSE, allow_playback_repeats: FALSE, preserve_exact_body_bytes: FALSE} [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Handling request: get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 (disabled: FALSE) [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Checking if {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} matches {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} using matchers: [method, uri] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - method matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - uri matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Identified request type: (stubbed_by_vcr) for get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Checking if {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} matches {get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1} using matchers: [method, uri] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - method matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - uri matched: current request [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] vs [get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1] [Cassette: &#39;foobar&#39;] - 2018-04-27 08:36:28 - Found matching interaction for get http://www.marinespecies.org/rest/AphiaChildrenByAphiaID/105706?marine_only=true&amp;offset=1 at index 1: ??? [{&quot;AphiaID&quot;:297110,&quot;url&quot;:&quot;http:\\/\\/www.marinespecies.org\\/aphia.php?p=taxdetails Internally vcr logs certain actions that we think are important steps in the process, including: initializing an HTTPInteractionList object that holds HTTP interactions initializing a Cassette with whatever options the user passes in declaring what request is being handled what request is being checked whether there is a match found or not when an interaction is recorded, or pulled from a stub, etc. If you turn off the date, you won’t get date entries: vcr::vcr_configure( log = TRUE, log_opts = list(file = &quot;vcr.log&quot;, log_prefix = &quot;Cassette&quot;, date = FALSE) ) [Cassette: &#39;foobar&#39;] - {{message}} And you can change the prefix from Cassette to something else: vcr::vcr_configure( log = TRUE, log_opts = list(file = &quot;vcr.log&quot;, log_prefix = &quot;Unicorn&quot;, date = FALSE) ) [Unicorn: &#39;foobar&#39;] - {{message}} "],
["security.html", "Chapter 9 security 9.1 API keys and such 9.2 Other security", " Chapter 9 security 9.1 API keys and such The configuration parameter filter_sensitive_data accepts a named list. Each element in the list should be of the following format: thing_to_replace_it_with = thing_to_replace We replace all instances of thing_to_replace with thing_to_replace_it_with. Before recording (writing to a cassette) we do the replacement and then when reading from the cassette we do the reverse replacement to get back to the real data. The before record replacement happens in an internal function write_interactions(), while before playback replacement happens in internal function YAML$deserialize_path() vcr_configure( filter_sensitive_data = list(&quot;&lt;&lt;&lt;my_api_key&gt;&gt;&gt;&quot; = Sys.getenv(&#39;API_KEY&#39;)) ) You want to make the string that replaces your sensitive string something that won’t be easily found elsewhere in the response body/headers/etc. It’s a good idea to not in place of thing_to_replace put your actual sensitive key thing, because that defeats the purpose of trying to protect your private data. This is why we highly recommend setting your API keys as environment variables, then you can as seen above just put a call to Sys.getenv(), which we’ll use internally to get your key, find it anywhere in the HTTP responses, and replace it with your placeholder string. The reason you want to do this is because you may on purpose or on accident push your cassettes to the public web, and when that happens you don’t want your private keys in those cassettes. Note that the way this is implemented in vcr is not super elegant and is not general with respect to the serializer. We only support YAML serializing right now, but when we support other serializers we’ll need to change the implementation. 9.2 Other security Let us know about any other security concerns! Surely there’s things we haven’t considered yet. "],
["escape-hatches.html", "Chapter 10 escape hatches 10.1 lightswitch: vcr, webmockr and their on/off states 10.2 turned_off 10.3 turn_off", " Chapter 10 escape hatches There’s many different scenarios for using vcr, some of which are that you have vcr loaded but you want to still make real HTTP requests. The following are different ways to allow real HTTP requests. 10.1 lightswitch: vcr, webmockr and their on/off states After loading vcr, webmockr is not loaded, thus real HTTP requests are allowed. library(vcr) After loading webmockr you can still make real HTTP requests. library(webmockr) But after turning mocking on you can’t make real requests crul::mock() # OR webmockr::enable() And you’ll get errors that come from webmockr when attempting real HTTP requests HttpClient$new(url = &quot;https://httpbin.org/get&quot;)$get() #&gt; Error: Real HTTP connections are disabled. #&gt; Unregistered request: GET https://httpbin.org/get with headers {Accept-Encoding: gzip, deflate} #&gt; #&gt; You can stub this request with the following snippet: #&gt; #&gt; stub_request(&#39;get&#39;, uri = &#39;https://httpbin.org/get&#39;) %&gt;% #&gt; wi_th(headers = list(&#39;Accept-Encoding&#39; = &#39;gzip, deflate&#39;)) You can have vcr loaded but if you’re not using use_casette 10.2 turned_off turned_off() lets you temporarily make a real HTTP request without completely turning vcr off, unloading it, etc. What happens internally is we turn off vcr, run your code block, then on exit turn vcr back on - such that vcr is onl turned off for the duration of your code block running. Even if your code block errors, vcr will be turned back on due to use of on.exit(turn_on()) library(vcr) library(crul) turned_off({ res &lt;- HttpClient$new(url = &quot;https://httpbin.org/get&quot;)$get() }) res #&gt; &lt;crul response&gt; #&gt; url: https://httpbin.org/get #&gt; request_headers: #&gt; User-Agent: libcurl/7.54.0 r-curl/3.2 crul/0.5.2 #&gt; Accept-Encoding: gzip, deflate #&gt; Accept: application/json, text/xml, application/xml, */* #&gt; response_headers: #&gt; status: HTTP/1.1 200 OK #&gt; server: nginx #&gt; date: Fri, 27 Apr 2018 23:22:44 GMT #&gt; content-type: application/json #&gt; content-length: 330 #&gt; connection: keep-alive #&gt; access-control-allow-origin: * #&gt; access-control-allow-credentials: true #&gt; x-powered-by: Flask #&gt; x-processed-time: 0 #&gt; status: 200 10.3 turn_off "],
["gotchas.html", "Chapter 11 gotchas", " Chapter 11 gotchas There’s a few things to watch out for when using vcr. Security: Don’t put your secure API keys, tokens, etc. on the public web. See the Security chapter (9) Dates: Be careful when using dates in tests with vcr. e.g. if you generate todays date, and pass that in to a function in your package that uses that date for an HTTP request, the date will be different from the one in the matching cassette, causing a vcr failure. HTTP errors: It’s a good idea to test failure behavior of a web service in your test suite. Sometimes vcr can handle that and sometimes it cannot. Open any issues about this because ideally i think vcr could handle all cases of HTTP failures. Very large response bodies: A few things about large response bodies. First, vcr may give you trouble with very large response bodies as we’ve see yaml parsing problems already. Second, large response bodies means large cassettes on disk - so just be aware of the file size if that’s something that matters to you. Third, large response bodies will take longer to load into R, so you may still have a multi second test run even though the test is using a cached HTTP response. Encoding: We haven’t dealt with encoding much yet at all, so we’re likely to run into encoding issues. One blunt instrument for this for now is to set preserve_exact_body_bytes = TRUE when running vcr::use_cassette() or vcr::insert_cassette(), which stores the response body as base64. devtools::check vs. devtools::test: At least one user has reported vcr not working as expected when using devtools::test() - but if they used devtools::check() vcr worked as expected. We haven’t dug into why this would be. Do report it if you run into this problem. "],
["session-info.html", "Chapter 12 session info", " Chapter 12 session info Session info for this book sessioninfo::session_info() #&gt; ─ Session info ────────────────────────────────────────────────────────── #&gt; setting value #&gt; version R version 3.5.2 Patched (2018-12-31 r75943) #&gt; os macOS Mojave 10.14.2 #&gt; system x86_64, darwin15.6.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz US/Pacific #&gt; date 2019-01-12 #&gt; #&gt; ─ Packages ────────────────────────────────────────────────────────────── #&gt; package * version date lib source #&gt; assertthat 0.2.0 2017-04-11 [1] CRAN (R 3.5.0) #&gt; base64enc 0.1-3 2015-07-28 [1] CRAN (R 3.5.0) #&gt; bookdown * 0.9.1 2019-01-10 [1] Github (rstudio/bookdown@dc33d2f) #&gt; cli 1.0.1 2018-09-25 [1] CRAN (R 3.5.1) #&gt; crayon 1.3.4 2017-09-16 [1] CRAN (R 3.5.0) #&gt; crul * 0.7.0 2019-01-04 [1] CRAN (R 3.5.2) #&gt; curl 3.3 2019-01-10 [1] CRAN (R 3.5.2) #&gt; digest 0.6.18 2018-10-10 [1] CRAN (R 3.5.1) #&gt; evaluate 0.12 2018-10-09 [1] CRAN (R 3.5.0) #&gt; fauxpas 0.2.0 2018-03-01 [1] CRAN (R 3.5.0) #&gt; htmltools 0.3.6 2017-04-28 [1] CRAN (R 3.5.0) #&gt; httpcode 0.2.0 2016-11-14 [1] CRAN (R 3.5.0) #&gt; httr 1.4.0 2018-12-11 [1] CRAN (R 3.5.0) #&gt; jsonlite 1.6 2018-12-07 [1] CRAN (R 3.5.1) #&gt; knitr * 1.21 2018-12-10 [1] CRAN (R 3.5.1) #&gt; lazyeval 0.2.1 2017-10-29 [1] CRAN (R 3.5.0) #&gt; magrittr 1.5 2014-11-22 [1] CRAN (R 3.5.0) #&gt; R6 2.3.0 2018-10-04 [1] CRAN (R 3.5.1) #&gt; Rcpp 1.0.0 2018-11-07 [1] CRAN (R 3.5.1) #&gt; rlang 0.3.1 2019-01-08 [1] CRAN (R 3.5.2) #&gt; rmarkdown 1.11.3 2019-01-10 [1] Github (rstudio/rmarkdown@b209cdc) #&gt; rstudioapi 0.9.0 2019-01-09 [1] CRAN (R 3.5.2) #&gt; sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.5.1) #&gt; stringi 1.2.4 2018-07-20 [1] CRAN (R 3.5.0) #&gt; stringr 1.3.1 2018-05-10 [1] CRAN (R 3.5.0) #&gt; testthat * 2.0.1 2018-10-13 [1] CRAN (R 3.5.0) #&gt; triebeard 0.3.0 2016-08-04 [1] CRAN (R 3.5.0) #&gt; urltools 1.7.1 2018-08-03 [1] CRAN (R 3.5.1) #&gt; vcr * 0.2.0 2018-10-19 [1] CRAN (R 3.5.0) #&gt; webmockr * 0.3.0 2019-01-09 [1] CRAN (R 3.5.2) #&gt; withr 2.1.2 2018-03-15 [1] CRAN (R 3.5.0) #&gt; xfun 0.4 2018-10-23 [1] CRAN (R 3.5.1) #&gt; yaml 2.2.0 2018-07-25 [1] CRAN (R 3.5.1) #&gt; #&gt; [1] /Library/Frameworks/R.framework/Versions/3.5/Resources/library "]
]
